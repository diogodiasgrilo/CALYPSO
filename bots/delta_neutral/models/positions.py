"""
positions.py - Position dataclasses for Delta Neutral strategy

This module defines the data structures for tracking option positions,
straddles, and strangles.
"""

from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from .states import PositionType


@dataclass
class OptionPosition:
    """
    Represents a single option position.

    Attributes:
        position_id: Unique identifier from the broker
        uic: Unique Instrument Code
        strike: Strike price
        expiry: Expiration date
        option_type: Call or Put
        position_type: Long or Short position
        quantity: Number of contracts
        entry_price: Price at entry
        current_price: Current market price
        delta: Position delta
        gamma: Position gamma (rate of change of delta)
        theta: Position theta (time decay)
        vega: Position vega (volatility sensitivity)
    """
    position_id: str
    uic: int
    strike: float
    expiry: str
    option_type: str  # "Call" or "Put"
    position_type: PositionType
    quantity: int
    entry_price: float
    current_price: float = 0.0
    delta: float = 0.0
    gamma: float = 0.0
    theta: float = 0.0
    vega: float = 0.0


@dataclass
class StraddlePosition:
    """
    Represents a straddle position (long call + long put at same strike).

    Attributes:
        call: The call option position
        put: The put option position
        initial_strike: The strike price at entry
        entry_underlying_price: Underlying price when position was opened
        entry_date: Date when the position was opened (for historical P&L tracking)
    """
    call: Optional[OptionPosition] = None
    put: Optional[OptionPosition] = None
    initial_strike: float = 0.0
    entry_underlying_price: float = 0.0
    entry_date: str = ""  # Format: YYYY-MM-DD or ISO timestamp

    @property
    def is_complete(self) -> bool:
        """Check if both legs of the straddle are active."""
        return self.call is not None and self.put is not None

    @property
    def total_delta(self) -> float:
        """Calculate total delta of the straddle."""
        call_delta = self.call.delta if self.call else 0
        put_delta = self.put.delta if self.put else 0
        return call_delta + put_delta

    @property
    def total_value(self) -> float:
        """Calculate total current value of the straddle."""
        call_value = (self.call.current_price * self.call.quantity * 100) if self.call else 0
        put_value = (self.put.current_price * self.put.quantity * 100) if self.put else 0
        return call_value + put_value


@dataclass
class StranglePosition:
    """
    Represents a strangle position (short call + short put at different strikes).

    Attributes:
        call: The short call option position
        put: The short put option position
        call_strike: Call strike price
        put_strike: Put strike price
        expiry: Expiration date
        entry_date: Date when the position was opened (for theta tracking)
    """
    call: Optional[OptionPosition] = None
    put: Optional[OptionPosition] = None
    call_strike: float = 0.0
    put_strike: float = 0.0
    expiry: str = ""
    entry_date: str = ""  # Format: YYYY-MM-DD

    @property
    def is_complete(self) -> bool:
        """Check if both legs of the strangle are active."""
        return self.call is not None and self.put is not None

    @property
    def total_delta(self) -> float:
        """Calculate total delta of the strangle."""
        call_delta = self.call.delta if self.call else 0
        put_delta = self.put.delta if self.put else 0
        return call_delta + put_delta

    @property
    def premium_collected(self) -> float:
        """Calculate total premium collected from selling the strangle."""
        call_premium = (self.call.entry_price * self.call.quantity * 100) if self.call else 0
        put_premium = (self.put.entry_price * self.put.quantity * 100) if self.put else 0
        return call_premium + put_premium

    @property
    def days_held(self) -> int:
        """Calculate number of days the position has been held."""
        if not self.entry_date:
            return 0
        try:
            entry = datetime.strptime(self.entry_date, "%Y-%m-%d")
            return (datetime.now() - entry).days
        except ValueError:
            return 0

    @property
    def days_to_expiry(self) -> int:
        """Calculate calendar days until expiration (not time-based)."""
        if not self.expiry:
            return 0
        try:
            expiry_date = datetime.strptime(self.expiry, "%Y-%m-%d").date()
            today = datetime.now().date()
            return max(0, (expiry_date - today).days)
        except ValueError:
            return 0
